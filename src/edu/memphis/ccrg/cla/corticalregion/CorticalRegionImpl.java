package edu.memphis.ccrg.cla.corticalregion;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

import cern.colt.bitvector.BitVector;
import edu.memphis.ccrg.cla.corticalregion.cells.Cell;
import edu.memphis.ccrg.cla.corticalregion.cells.CellState;
import edu.memphis.ccrg.cla.corticalregion.columns.Column;
import edu.memphis.ccrg.cla.corticalregion.connections.DendriteSegment;
import edu.memphis.ccrg.cla.corticalregion.connections.DendriteSegmentImpl;
import edu.memphis.ccrg.cla.corticalregion.connections.SegmentUpdate;
import edu.memphis.ccrg.cla.corticalregion.connections.SegmentUpdateImpl;
import edu.memphis.ccrg.cla.corticalregion.connections.SegmentUpdateType;
import edu.memphis.ccrg.cla.corticalregion.connections.Synapse;
import edu.memphis.ccrg.cla.corticalregion.initialization.CorticalRegionDef;
import edu.memphis.ccrg.cla.corticalregion.initialization.CorticalRegionFactory;
import edu.memphis.ccrg.cla.corticalregion.initialization.CorticalRegionInitializer;
import edu.memphis.ccrg.cla.corticalregion.tasks.FullCorticalRegionTask;
import edu.memphis.ccrg.cla.gui.CorticalRegionAspect;
import edu.memphis.ccrg.cla.gui.CorticalRegionVisualizer;
import edu.memphis.ccrg.cla.logging.ClaMeasure;
import edu.memphis.ccrg.cla.strategies.BoostStrategy;
import edu.memphis.ccrg.cla.strategies.DefaultBoostStrategy;
import edu.memphis.ccrg.cla.strategies.ParameterUpdateStrategy;
import edu.memphis.ccrg.cla.utils.ClaUtils;
import edu.memphis.ccrg.lida.framework.FrameworkModuleImpl;
import edu.memphis.ccrg.lida.framework.initialization.GlobalInitializer;
import edu.memphis.ccrg.lida.framework.shared.ElementFactory;
import edu.memphis.ccrg.lida.framework.strategies.DecayStrategy;
import edu.memphis.ccrg.lida.framework.strategies.ExciteStrategy;
import edu.memphis.ccrg.lida.framework.tasks.TaskManager;

/**
 * An implementation of the HTM Cortical Learning Algorithms CorticalRegion (http://numenta.org/). 
 * This implementation features a 2D topology with 2D receptive fields on columns allowing the algorithm to process
 * "natural" data signals, not just artificial ones. 
 * Each region is driven by task (thread) running a serial cycle.
 * 
 * @see {@link FullCorticalRegionTask}
 * 
 * @author Ryan J. McCall
 */
public class CorticalRegionImpl extends FrameworkModuleImpl implements CorticalRegion, CorticalRegionBottomUpSource {
	
	//For refactoring this class into 2 submodules:
	//Have the cortical region task in this module, set up input module via listener xml functionality possibly
	//add module names Columns and Cells to ModuleName enum
	//Split stats into cells part and columns part
	//Start by encapsulating Columns in 1 data structure
	
	private static final Logger logger = Logger.getLogger(CorticalRegionImpl.class.getCanonicalName());
	private static final ElementFactory elementFactory = ElementFactory.getInstance();
	private static final CorticalRegionFactory regionFactory = CorticalRegionFactory.getInstance();
	private static final GlobalInitializer globalInitializer = GlobalInitializer.getInstance();
	
	/*
	 * The current bottom up input to the region.
	 */
	protected BitVector bottomUpInput;
	/*
	 * The structural prediction generated by this region, based on the nextCyclePredictedColumns. 
	 */
	protected BitVector generatedStructuralPrediction;
	/*
	 * The bottomUpInput that was not structurally predicted. Does not include false positive predictions.
	 * Specifically it is the logical and-not of the bottomUpInput and the generatedStructuralPrediction 
	 */
	protected BitVector inputError;	
	/*
	 * The current output of this region
	 */
	protected BitVector regionOutput;
	/*
	 * The prediction of cell activity from the next hierarchical level
	 */
	protected BitVector receivedStructuralPrediction;	
	
	/*
	 * Strategy used to decay synapse permanence.
	 */
	private DecayStrategy decayStrategy;
	private static final String DEFAULT_DECAY_STRATEGY_NAME = "defaultClaDecay";
	
	private static final double DEFAULT_INPUT_PROJECTION_FACTOR = 1.0;
	/*
	 * The square root of the bottom-up input, used for the square 2D characterization of
	 * the input assumed by this implementation.
	 */
	protected int bottomUpInputSizeSqrt;

	/*
	 * Dimension of bottom-up input.
	 */
	private int bottomUpInputDimension;
	/*
	 * The ratio of 1) the bottom-up input dimensionality to 2) the number of columns in the region.
	 */
	private double inputToColumnRatio;
	/*
	 * Width of the region's array of columns.
	 */
	protected int regionWidth;
	/*
	 * Height of the region's array of columns.
	 */
	protected int regionHeight;
	/*
	 * Number of cells per column for all columns in the region.
	 */
	protected int cellsPerColumn;
	/*
	 * The total number of columns in the region
	 */
	protected int columnCount;
	/*
	 * The total number of cells in the region
	 */
	private int cellCount;
	/*
	 * The connection threshold for synapse permanence, i.e., permanence must be above 
	 * this value for the synapse to be considered connected.
	 */
	protected double synapseConnectionThreshold;

	/*
	 * Wrapper for the statistics recorded each processing cycle.
	 */
	protected CorticalRegionStatistics loggingStats = new CorticalRegionStatistics();
	
	/*
	 * For each input, the number of unique proximal synapses with that input as
	 * their source.
	 */
	private int[] inputCoverage;
	/*
	 * Threshold used to determine if a structural prediction (double) counts
	 * towards cell activation
	 */
	protected double structuralPredictionThreshold;
	private static final double DEFAULT_PREDICTION_THRESHOLD = 0.0;

	/*
	 * Columns of the region in a square 2D arrangement. The first index is "region height" and 
	 * the second is "region width."
	 */
	protected Column[][] columns;
	/*
	 * A map where each entry consists of a Column and its neighboring columns
	 * defined by a circle of radius, inhibitionRadius. Since inhibitionRadius may
	 * change, this map may need updated with each change.
	 */
	protected Map<Column, List<Column>> inhibitionNeighbors = new HashMap<Column, List<Column>>();
	/*
	 * The inhibition radius value the last time the "inhibitionNeighbors" map
	 * was updated.
	 */
	private double storedInhibitionRadius;
	/*
	 * Amount of change in inhibition radius tolerated before the inhibitionNeighbors map will be updated.
	 */
	private double inhibitionRadiusChangeTolerance;
	private static final double DEFAULT_INHIBITION_RADIUS_CHANGE_TOLERANCE = 0.001;	
	
	/*
	 * A subset of the columns with at least 'columnOverlapThreshold' overlap.
	 */
	protected Collection<Column> overlappingColumns = Collections.newSetFromMap(new ConcurrentHashMap<Column,Boolean>()); 
	/*
	 * A subset of the columns that won the inter-column inhibition on the current time step.
	 */
	protected Collection<Column> activeColumns = Collections.newSetFromMap(new ConcurrentHashMap<Column,Boolean>());
	/*
	 * The columns that are predicted by the current active state and top-down
	 * prediction.
	 */
	protected Collection<Column> oneOrderPredictedColumns = Collections.newSetFromMap(new ConcurrentHashMap<Column,Boolean>());
	/*
	 * The currentPredictedColumns from the previous processing cycle.
	 */
	protected Collection<Column> onePreviousPredictedColumns = Collections.newSetFromMap(new ConcurrentHashMap<Column,Boolean>());
	
	protected Collection<Column> allPredictedColumns = Collections.newSetFromMap(new ConcurrentHashMap<Column,Boolean>());
	
	/*
	 * Strategy used to update column boost.
	 */
	private BoostStrategy boostStrategy;
	private static final String DEFAULT_BOOST_STRATEGY_NAME = "defaultBoostStrategy";
	
	/*
	 * Minimum percentage of a column's potential synapses that must be active
	 * (connected and receiving input) for the column to be considered
	 * sufficiently overlapped with the input. Such overlapping columns enter
	 * into competition with other.
	 */
	protected double columnOverlapThreshold;
	private static final double DEFAULT_COLUMN_OVERLAP_THRESHOLD = 0.05;
	/*
	 * Number of active columns after inhibition step that are within a circle
	 * of size 'inhibitionRadius'.
	 * That is to say, the smaller this parameter's value, the less active columns in general.
	 * Larger parameter values allow more active columns. 
	 */
	protected double localColumnActivity;
	protected ParameterUpdateStrategy lcaUpdateStrategy;
	private static final String DEFAULT_LCA_UPDATE_STRATEGY = "noUpdateStrategy";

	/*
	 * Specifies the size of the neighborhood which a column may potentially
	 * inhibit
	 */
	protected double inhibitionRadius;
	/*
	 * A percentage of the max average activity of neighboring columns which a
	 * column should have. (If not then the column will be boosted.)
	 */
	private double minColumnActivityPercentage;
	private static final double DEFAULT_MIN_COLUMN_ACTIVITY_PERCENTAGE = 0.01;
	/*
	 * Amount of permanence added to proximal synapses when they are positively
	 * reinforced.
	 */
	protected double proximalPermanenceIncrement;
	/*
	 * Amount of permanence removed from proximal synapses when they are
	 * negatively reinforced.
	 */
	protected double proximalPermanenceDecrement;
	/*
	 * Cells are indexed by 1. region height 2. region width, and 3. column
	 * position
	 */
	protected Cell[][][] cells;
	/*
	 * A map of the learning cell indices in the column dimension.
	 * For each active column we maintain an entry where the column is the key 
	 * and the value is the currently selected learning cell for the column.
	 */
	private Map<Column, Integer> learningCellIndices = new HashMap<Column, Integer>();
	/*
	 * A map where each entry consists of a Column and its neighboring columns
	 * within a circle of radius, distalLearningRadius. Since
	 * distalLearningRadius is fixed, this map only needs to be created once at
	 * initialization.
	 */
	private Map<Column, List<Column>> distalLearningNeighbors = new HashMap<Column, List<Column>>();
	/*
	 * A queue storing the current potential SegmentUpdates. Each position in the queue 
	 * represents a run cycle in the future. The segment updates at a given position
	 * are those which can be verified as correctly predicting or not at that time.
	 * Each cycle the queue advances time by removing the first position, processing that position
	 * and then adding a new position at the last position.
	 * The length of the queue is initialized to, and maintained at, a value of 'predictionOrderLimit' 
	 * (N.b., a LinkedList is both a List and a Queue.)
	 */
	private List<Collection<SegmentUpdate>> storedSegmentUpdates = new LinkedList<Collection<SegmentUpdate>>();
	
	/*
	 * Offset for regionHeight index for converting 3D array addresses to 1D
	 * addresses.
	 */
	protected int heightIndexOffset;	
	/*
	 * Dendrite segment activation threshold in terms of active synapses.
	 */
	private int distalDendriteActivationThreshold;
	/*
	 * Minimum number of active synapses on a distal dendrite segment required
	 * for learning.
	 */
	protected int segmentLearningThreshold;
	private static final int DEFAULT_SEGMENT_LEARNING_THRESHOLD = 12;
	
	/*
	 * Limit on the order of prediction for prediction-extending segment updates.   
	 */
	private int predictionOrderLimit;
	private static final int DEFAULT_PREDICTION_ORDER_LIMIT = 2;
	
	/*
	 * Radius used to gather neighboring Cells to be used as the sources of
	 * distal synapses.
	 */
	private double distalLearningRadius;
	/*
	 * The max number of new distal synapses that may be added per segment update
	 */
	private int maxNewDistalSynapsesPerUpdate;
	private static final int DEFAULT_NEW_SYNAPSES_PER_UPDATE = 20;
	
	/*
	 * The max number of distal synapses that are allowed on distal dendrite segments writ broad. 
	 */
	private int maxDistalSynapsesPerSegment; 
	private static final int DEFAULT_MAX_DISTAL_SYNAPSES_PER_SEGMENT = 32;
	
	/*
	 * initial distal synapse permanence
	 */
	private double initialDistalSynapsePermanence;

	private double distalPermanenceIncrement;
	private double distalPositivePermanenceDecrement;
	/*
	 * Amount of permanence removed from synapses when they are part of a
	 * negative segment update and must be negatively reinforced.
	 */
	private double distalNegativePermanenceDecrement;
	private static final double DEFAULT_PERMANENCE_INCREMENT = 0.1;
	private static final double DEFAULT_PERMANENCE_DECREMENT = -0.1;
	
	/**
	 * Intended to be called by {@link CorticalRegionInitializer}. The following
	 * {@link GlobalInitializer} parameter should be specified in the agent xml
	 * file: <br/>
	 * <b>inputSignalDimensionality</b> (int) - original dimensionality of the
	 * input this region receives The following {@link CorticalRegionImpl}
	 * parameters may be specified in the agent xml file: <br/>
	 * 
	 * <h1>Shared Parameters</h1><br/>
	 * <b>synapseConnectionThreshold</b> (double) - threshold for synapse
	 * connectivity in terms of synapse permanence.<br/>
	 * <b>exciteStrategyName</b> (String) - {@link ElementFactory} name of the
	 * {@link ExciteStrategy} used to adjust Synapse permanence.<br/>
	 * <b>decayStrategyName</b> (String) - {@link ElementFactory} name of the
	 * {@link DecayStrategy} used to decay synapse permanence.<br/>
	 * <br/>
	 * <h1>Spatial Pooler Parameters</h1><br/>
	 * <b>columnOverlapThreshold</b> (double) - minimum percentage of proximal
	 * synapse activity a column must have for the overlap to be counted.<br/>
	 * <b>minColumnActivityPercentage</b> (double) - A percentage of the max
	 * average activity of neighboring columns which determines when a column
	 * should be boosted.<br/>
	 * <b>boostStrategyName</b> (String) - Factory name of the
	 * {@link BoostStrategy} used by the region.<br/>
	 * <b>boostStrategyName</b> (String) - {@link ElementFactory} name of the
	 * {@link BoostStrategy} used to adjust {@link Synapse} permanence<br/>
	 * <br/>
	 * <h1>Temporal Pooler Parameters</h1><br/>
	 * <b>distalDendriteActivationThreshold</b> (int) - {@link DendriteSegment}
	 * activation threshold in terms of active synapses.<br/>
	 * <b>segmentLearningThreshold</b> (int) - Minimum number of active synapses
	 * on a distal {@link DendriteSegment} required for learning.<br/>
	 * <b>maxNewSynapsesPerSegment</b> (int) - Maximum number of learned
	 * synapses allowed per {@link SegmentUpdate}.<br/>
	 * 
	 * @param shouldLogInitialState
	 */
	public void initCorticalRegion(String defName, boolean shouldLogInitialState) {		
		int originalInputDimension = (Integer) globalInitializer.getAttribute("inputSignalDimensionality");
		double inputProjectionFactor = getParam("inputProjectionFactor",DEFAULT_INPUT_PROJECTION_FACTOR);
		if (Math.sqrt(originalInputDimension)%1.0 != 0.0) {
			logger.log(Level.SEVERE,
					"Original input signal does not have a square number (equal some integer squared) dimension.");
		}
		if ((originalInputDimension*inputProjectionFactor) % 1.0 != 0.0) {
			logger.log(Level.SEVERE,
					"Input dimensionality must be of an integer size: {0}",
					originalInputDimension*inputProjectionFactor);
		}
		bottomUpInputDimension = (int) (originalInputDimension*inputProjectionFactor);
		if(Math.sqrt(bottomUpInputDimension)%1.0 != 0.0){
			logger.log(Level.SEVERE,
					"Region input does not have a square number (equal some integer squared) dimension.");
		}
		bottomUpInputSizeSqrt = (int) Math.sqrt(bottomUpInputDimension);
		columns = regionFactory.getColumns(defName, bottomUpInputSizeSqrt, bottomUpInputSizeSqrt);
		regionHeight = columns.length;
		regionWidth = columns[0].length;
		columnCount = regionWidth*regionHeight;
		inputToColumnRatio = (double) bottomUpInputSizeSqrt / regionWidth;
		inputCoverage = ClaUtils.getInputCoverage(columns, bottomUpInputSizeSqrt);
		cells = regionFactory.getCells(defName, regionHeight, regionWidth);
		cellsPerColumn = cells[0][0].length;
		cellCount = columnCount*cellsPerColumn;
		heightIndexOffset = regionWidth*cellsPerColumn;
		initParameters();
		initOtherFields();
		if (shouldLogInitialState) {
			logInitialState(defName);
		}
	}

	protected void initParameters() {
		synapseConnectionThreshold = getParam("synapseConnectionThreshold",CorticalRegionDef.DEFAULT_SYNAPSE_CONNECTION_THRESHOLD);
		proximalPermanenceIncrement = getParam("proximalPermanenceIncrement",DEFAULT_PERMANENCE_INCREMENT);
		proximalPermanenceDecrement = getParam("proximalPermanenceDecrement",DEFAULT_PERMANENCE_DECREMENT);
		distalPermanenceIncrement = getParam("distalPermanenceIncrement",DEFAULT_PERMANENCE_INCREMENT);
		distalPositivePermanenceDecrement = getParam("distalPositivePermanenceDecrement",DEFAULT_PERMANENCE_DECREMENT);
		distalNegativePermanenceDecrement = getParam("distalNegativePermanenceDecrement",DEFAULT_PERMANENCE_DECREMENT);
		String strategyName = getParam("decayStrategyName", DEFAULT_DECAY_STRATEGY_NAME);
		decayStrategy = elementFactory.getDecayStrategy(strategyName);
		structuralPredictionThreshold = getParam("structuralPredictionThreshold", DEFAULT_PREDICTION_THRESHOLD);
		// Spatial pooler parameters
		columnOverlapThreshold = getParam("columnOverlapThreshold",DEFAULT_COLUMN_OVERLAP_THRESHOLD);
		inhibitionRadiusChangeTolerance = getParam("inhibitionRadiusChangeTolerance",
													DEFAULT_INHIBITION_RADIUS_CHANGE_TOLERANCE);
		localColumnActivity = getParam("localColumnActivity", 3D);
		strategyName = getParam("lcaUpdateStrategyName",DEFAULT_LCA_UPDATE_STRATEGY);
		lcaUpdateStrategy = (ParameterUpdateStrategy) elementFactory.getStrategy(strategyName);
		minColumnActivityPercentage = getParam("minColumnActivityPercentage",DEFAULT_MIN_COLUMN_ACTIVITY_PERCENTAGE);
		strategyName = getParam("boostStrategyName",DEFAULT_BOOST_STRATEGY_NAME);
		boostStrategy = (BoostStrategy) elementFactory.getStrategy(strategyName);
		// Temporal pooler parameters
		distalLearningRadius = getParam("distalLearningRadius",
				CorticalRegionDef.DEFAULT_DISTAL_LEARNING_RADIUS);
		distalDendriteActivationThreshold = getParam("distalDendriteActivationThreshold",
				CorticalRegionDef.DEFAULT_DISTAL_DENDRITE_ACTIVATION_THRESHOLD);
		segmentLearningThreshold = getParam("segmentLearningThreshold",
				DEFAULT_SEGMENT_LEARNING_THRESHOLD);		
		predictionOrderLimit = getParam("predictionOrderLimit",DEFAULT_PREDICTION_ORDER_LIMIT);		
		maxNewDistalSynapsesPerUpdate = getParam("maxNewDistalSynapsesPerUpdate",
											DEFAULT_NEW_SYNAPSES_PER_UPDATE);
		if (maxNewDistalSynapsesPerUpdate > columnCount) {
			logger.log(Level.WARNING,
					"'maxNewDistalSynapsesPerUpdate' {1} cannot exceed 'columnCount' {2}",
					new Object[] { TaskManager.getCurrentTick(),maxNewDistalSynapsesPerUpdate, columnCount });
			maxNewDistalSynapsesPerUpdate = columnCount;
		}
		maxDistalSynapsesPerSegment = getParam("maxDistalSynapsesPerSegment",DEFAULT_MAX_DISTAL_SYNAPSES_PER_SEGMENT);
		initialDistalSynapsePermanence = getParam("initialDistalSynapsePermanence",
							CorticalRegionDef.DEFAULT_INITIAL_DISTAL_SYNAPSE_PERMANENCE);
	}
	private void initOtherFields() {
		bottomUpInput = new BitVector(bottomUpInputDimension);
		generatedStructuralPrediction = new BitVector(bottomUpInputDimension);
		regionOutput = new BitVector(regionHeight * regionWidth * cellsPerColumn);
		receivedStructuralPrediction = new BitVector(cellCount);
		clearPotentialSegmentUpdates();
		initDistalNeighborhoods();
	}
	private void clearPotentialSegmentUpdates() {
		storedSegmentUpdates.clear();
		for(int i = 0; i <= predictionOrderLimit; i++){
			storedSegmentUpdates.add(new ArrayList<SegmentUpdate>());
		}
	}
	private void initDistalNeighborhoods(){
		for (Column[] columnArray: columns) {// Compute fixed distal neighborhoods
			for (Column col: columnArray) {
				List<Column> neighbors = ClaUtils.getNeighbors(col,distalLearningRadius,columns);
				neighbors.remove(col);
				Collections.shuffle(neighbors, regionFactory.getRandom());
				distalLearningNeighbors.put(col, neighbors);
			}
		}
	}
	private void logInitialState(String defName) {
		logger.log(Level.INFO, "Loaded CorticalRegionDef: {1}", new Object[] {
				TaskManager.getCurrentTick(), defName });
		logger.log(Level.INFO, "Columns: {1}",
				new Object[] { TaskManager.getCurrentTick(), columnCount });
		int initProxSynapses = 0;
		for (Column[] columnArray : columns) {
			for (Column c: columnArray) {
				initProxSynapses += c.getPotentialSynapseCount();
			}
		}
		logger.log(Level.INFO, "Proximal Synapses: {1}", new Object[] {
				TaskManager.getCurrentTick(), initProxSynapses });
		computeInhibitionRadius();
		logger.log(Level.INFO, "Initial inhibition Radius: {1}", new Object[] {
				TaskManager.getCurrentTick(), inhibitionRadius });
		logger.log(Level.INFO, "Cells: {1}",
				new Object[] { TaskManager.getCurrentTick(), cellCount });
		CorticalRegionDef def = regionFactory.getCorticalRegionDef(defName);
		int distalSegments = cellCount * def.getDendritesPerCell();
		logger.log(Level.INFO, "Distal DendriteSegments: {1}", new Object[] {
				TaskManager.getCurrentTick(), distalSegments });
		logger.log(Level.INFO, "Initial Distal Synapses: {1}",
				new Object[] {TaskManager.getCurrentTick(),
						def.getIntialSynapsesPerDistalSegment()*distalSegments});
	}

	/**
	 * Initializes all time-based data structures in the region for the next
	 * time step including: active columns, {@link DendriteSegment}s, potential
	 * {@link SegmentUpdate}s, and active, predictive and learning states.
	 */
	public void setupForCycle(BitVector input) {
		bottomUpInput = input;
		BitVector inputCopy = input.copy();
		inputCopy.andNot(generatedStructuralPrediction);
		inputError = inputCopy;
		setupColumnState();
		setupCellState();
		loggingStats.clearStatistics();
	}

	protected void setupColumnState() {
		overlappingColumns.clear();
		activeColumns.clear();
		onePreviousPredictedColumns.clear();
		onePreviousPredictedColumns.addAll(oneOrderPredictedColumns);
		oneOrderPredictedColumns.clear();
		allPredictedColumns.clear();
		updateInhibitionRadius();
	}
	private void updateInhibitionRadius() {
		computeInhibitionRadius();
		if (Math.abs(storedInhibitionRadius-inhibitionRadius) > inhibitionRadiusChangeTolerance) {
			storedInhibitionRadius = inhibitionRadius;
			for (Column[] columnArray: columns) {
				for (Column c: columnArray) {
					List<Column> cols = ClaUtils.getNeighbors(c, inhibitionRadius, columns);
					inhibitionNeighbors.put(c, cols);
				}
			}
		}
	}
	private void computeInhibitionRadius() {
		double aveDistanceSum = 0.0;
		for (Column[] columnArray: columns) {
			for (Column column: columnArray) {
				aveDistanceSum += getAverageConnectedSynapseDistance(column);
			}
		}
		inhibitionRadius = aveDistanceSum/columnCount;
	}
	/**
	 * Gets the size of the receptive field of the column's <i>connected</i>
	 * proximal synapses.
	 * 
	 * @return the size of specified column's receptive field in the column (not
	 *         input) coordinate system.
	 */
	double getAverageConnectedSynapseDistance(Column c) {
		double distanceSum = 0.0;
		Collection<Synapse> synapses = c.getConnectedSynapses();
		for (Synapse s: synapses) {
			double dx = c.getInputWidthPosition() - s.getSourceWidthPos();
			double dy = c.getInputHeightPosition() - s.getSourceHeightPos();
			distanceSum += Math.sqrt(dx*dx + dy*dy);
		}
		return synapses.size()==0? 0.0: distanceSum/(inputToColumnRatio*synapses.size());
	}
	private void setupCellState() {
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for(int k = 0; k < cellsPerColumn; k++){
					cells[i][j][k].advanceTime();
				}				
			}
		}
		learningCellIndices.clear();
	}

	/**
	 * Phase 1 of Spatial Pooling. Updates the current overlap value for all
	 * columns. Overlap is based on how well the column's proximal synapse
	 * "matches" the input.
	 */
	@Override
	public void performSpatialPooling() {
		double boostedOverlap = 0;
		double overlapScore = 0;
		for (Column[] columnArray: columns) {
			for (Column col: columnArray) {
				boostedOverlap = 0;
				if(col.getPotentialSynapseCount() > 0){
					overlapScore = 0;
					for (Synapse s: col.getConnectedSynapses()) {
						if (bottomUpInput.get(s.getSourceHeightPos()*bottomUpInputSizeSqrt+s.getSourceWidthPos())) {
							overlapScore++;
						}
					}
					overlapScore /= col.getPotentialSynapseCount();
					if (overlapScore > columnOverlapThreshold) { 			 
						boostedOverlap = overlapScore*col.getBoost();
						overlappingColumns.add(col);
					}
				}
				col.setBoostedOverlap(boostedOverlap);
			}
		}
		calculateInterColumnInhibition(overlappingColumns);
	}

	/**
	 * Phase 2 of Spatial Pooling. Choose a sparse set of active columns for the
	 * current time.
	 */
	protected void calculateInterColumnInhibition(Collection<Column> overlappingColumns) {
		double inhibitionArea = Math.PI*Math.pow(inhibitionRadius, 2);
		double maxPossibleNeighbors = Math.min(inhibitionArea, columnCount);
		for (Column c: overlappingColumns) {
			List<Column> neighbors = inhibitionNeighbors.get(c);
			if (neighbors != null) {
				Column kthCol = getKthColumn(neighbors, maxPossibleNeighbors);
				if (kthCol != null &&
						c.getBoostedOverlap() >= kthCol.getBoostedOverlap()) {
					activeColumns.add(c);
				}
			} else {
				logger.log(Level.WARNING,
						"Could not get neighbors for column {1}", new Object[] {
								TaskManager.getCurrentTick(), c });
			}
		}
	}

	/**
	 * Returns the overlap of the column with the kth highest overlap among the
	 * specified columns. k is equal to {@link #localColumnActivity} parameter.
	 * 
	 * @param neighbors
	 *            a collection of neighboring columns
	 * @param maxNumNeighbors
	 *            the most possible neighbors a column could have given current
	 *            {@link #inhibitionRadius}.
	 * @return the {@link Column} with the kth highest overlap.
	 */
	Column getKthColumn(List<Column> neighbors, double maxNumNeighbors) {
		Column column = null;
		if (maxNumNeighbors > 0.0) {
			double scaling = neighbors.size() / maxNumNeighbors; // Harder to win as neighborhood size decreases.
			int index = (int) Math.round(scaling*localColumnActivity)-1;
			if (index >= 0 && index < neighbors.size()) {
				Collections.sort(neighbors);
				column = neighbors.get(index);
			}
		}
		return column;
	}

	/**
	 * Phase 3 of Spatial Pooling. Performs Hebbian learning for all potential
	 * proximal synapses. The presence of presynaptic activity determines
	 * whether synapses is positively or negatively adjusted. 
	 * Decrease inactive synapses; we already have enough active synapses 
	 * for an active column & don't want too many.
	 * 
	 * Also updates each Column's boosting. 
	 */
	@Override
	public void performSpatialLearning() {
		cycleSpatialSynapticChanges = 0;
		for (Column column: activeColumns) {
			for (Synapse s: column.getPotentialSynapses()) {
				int inputIndex = s.getSourceHeightPos()*bottomUpInputSizeSqrt + s.getSourceWidthPos();
				double amount = bottomUpInput.get(inputIndex)? 
									proximalPermanenceIncrement: proximalPermanenceDecrement;
				updatePermanence(s, column, amount);
			}
			cycleSpatialSynapticChanges += column.getPotentialSynapseCount();
		}
		for (Column[] columnArray: columns) {
			for (Column c: columnArray) {
				updateColumnBoosting(c);
			}
		}
	}
	protected int cycleSpatialSynapticChanges;

	/**
	 * Updates specified column's boost value. If the column's recent activity
	 * is low then its boost is increased. Additionally, if the column synapses
	 * have low recent overlap activity then their permanence values are
	 * boosted.
	 * 
	 * @param i
	 *            column's height position
	 * @param j
	 *            column's width position
	 */
	protected void updateColumnBoosting(Column column) {
		column.updateActiveHistory(activeColumns.contains(column));
		List<Column> neighbors = inhibitionNeighbors.get(column);
		double minColumnActivityAllowed = minColumnActivityPercentage*getMaxAverageActivity(neighbors);
		double boost = boostStrategy.getBoostValue(column.getAverageActivity(),minColumnActivityAllowed);
		column.setBoost(boost); // Update column's boost
		if (boost > loggingStats.maxBoostInCycle) {// For logging
			loggingStats.maxBoostInCycle = boost;
		}
		// 'minAverageColumnActivity' is based on average activity, 
		// a more strict measure of activity than overlap history, which would
		// be improved by boosting proximal synapses.
		boostProxmialSynapses(column, minColumnActivityAllowed);
	}
	void boostProxmialSynapses(Column column, double minColumnActivity) {
		column.updateOverlapHistory(column.getBoostedOverlap() > 0.0);// True if c had sufficient overlap.
		if (column.getAverageOverlap() < minColumnActivity) {
			for (Synapse s: column.getPotentialSynapses()) {
				updatePermanence(s, column, proximalPermanenceIncrement);
			}
			loggingStats.columnsWithBoostedSynapses++;
		}
	}
	private double getMaxAverageActivity(Collection<Column> cols) {
		double maxAverageActivity = 0.0;
		if (cols != null) {
			for (Column col: cols) {
				if (col.getAverageActivity() > maxAverageActivity) {
					maxAverageActivity = col.getAverageActivity();
				}
			}
		}
		return maxAverageActivity;
	}

	/**
	 * Updates the permanence of specified synapse by specified amount. 
	 * If the update makes permanence 0.0 or less the synapse is removed both
	 * as a potential synapse and connected synapse from its {@link DendriteSegment}.
	 * Otherwise, if the update produces permanence above the {@link #synapseConnectionThreshold}
	 * the synapse is added as a connected synapse, else if below, the synapse is removed as connected.
	 * 
	 * @param s {@link Synapse} whose permanence will be updated
	 * @param ds the {@link DendriteSegment} sink that the {@link Synapse} feeds into
	 * @param amount the degree of the change to the synapse's permanence
	 */
	protected void updatePermanence(Synapse s, DendriteSegment ds, double amount) {
		double p = s.getPermanence() + amount;
		if (p > 0.0) {
			s.setPermanence(p);
			if (p > synapseConnectionThreshold) {
				ds.addConnectedSynapse(s);
			} else {
				ds.removeConnectedSynapse(s);
			}
		} else {
			ds.removePotentialSynapse(s);
			loggingStats.distalSynapsesRemoved++;
		}
	}
	
	@Override
	public void performTemporalPooling(){
		updateActiveCells();
		updatePredictiveCells();
		processStructuralPrediction();
		computeOutput();
	}

	/**
	 * Temporal Pooler Phase 1. For each active column, mark some column cells
	 * active and choose a few learning cell(s).
	 */
	public void updateActiveCells() {
		for (Column c: activeColumns) {
			updateColumnActiveCells(c.getRegionHeightPosition(),c.getRegionWidthPosition());
		}
	}
	/**
	 * Updates the active state of the cells in the specified active column.
	 * Also chooses a learning cell for the column, for which learning on the distal synapses might occur.
	 * A learning cell is either 1) currently predicted by learning cells for the next time step <br/>
	 * or 2) chosen on the basis of the strength of its current lateral prediction.  
	 * 
	 * @param h column's height position in the region
	 * @param w column's width position in the region 
	 * Runtime O(cell*(2*ds+1)*s_d)
	 */
	void updateColumnActiveCells(int h, int w) {
		boolean activityPredicted = false;
		boolean learningCellChosen = false;
		DendriteSegment activeSegment = null;
		for (int i = 0; i < cellsPerColumn; i++) {
			if (cells[h][w][i].isPredictedPreviously()) {
				activeSegment = getBest1OrderPredictingSegment(cells[h][w][i].getDendriteSegments());
				loggingStats.correctlyPredictingCells++;
				if (activeSegment != null) {
					loggingStats.activePredictingSegment++;
					if (activeSegment.isPredictingForNextStep()) {
						cells[h][w][i].setActiveCurrently(true);
						activityPredicted = true;
						loggingStats.activePredictingSequenceSegments++;
						if (isSegmentActive(activeSegment.getConnectedSynapses(),CellState.LearningPrevious)) {
							cells[h][w][i].setLearningCurrently(true);
							learningCellIndices.put(columns[h][w], i);
							learningCellChosen = true;
							loggingStats.learningActivePredictingSequenceSegments++;
						}
					}
				}
			}
		}
		if (!activityPredicted) {
			for (int i = 0; i < cellsPerColumn; i++) {
				cells[h][w][i].setActiveCurrently(true);
			}
		}
		if (!learningCellChosen) {
			getLearningCell(h, w);
			loggingStats.chosenLearningCellCount++;
		}
	}
	/**
	 * Returns the maximally-active 1-order predicting {@link DendriteSegment} of those provided. 
	 * "Active" here implies there are more than {@link #distalDendriteActivationThreshold} 
	 * synapses active. If currently-predicting segments are not sufficiently active, then
	 * a non-currently-predicting segments may be returned. If no segments are sufficiently active, then null is returned. 
	 * 
	 * @see #updateActiveCells()
	 * @see DendriteSegment#isPredictingNextTick() 
	 * O(ds*s_d)
	 */
	DendriteSegment getBest1OrderPredictingSegment(Collection<DendriteSegment> segments) {
		DendriteSegment predictingMax = null;
		DendriteSegment nonPredictingMax = null;
		int maxPredictingSynapses = 0;
		int maxNonPredictingSynapses = 0;
		for (DendriteSegment ds: segments) {
			int activeSynapseCount = getActiveSynapseCount(ds.getConnectedSynapses(),
														   CellState.ActivePrevious);
			if (activeSynapseCount > distalDendriteActivationThreshold) {
				if (ds.isPredictingForNextStep()) {
					if (activeSynapseCount > maxPredictingSynapses) {
						maxPredictingSynapses = activeSynapseCount;
						predictingMax = ds;
					}
				} else if (activeSynapseCount > maxNonPredictingSynapses) {
					maxNonPredictingSynapses = activeSynapseCount;
					nonPredictingMax = ds;
				}
			}
		}// Give precedence to a predicting winner.
		return (predictingMax != null)? predictingMax: nonPredictingMax;
	}

	/**
	 * Chooses a cell in the specified column to be the column's learning cell.
	 * The chosen cell is one that is sufficiently well-predicted at the last time
	 * step, or, if none are well-predicted, one is chosen at random. A
	 * {@link SegmentUpdate} with new synapses is stored for the chosen cell.
	 * This helps start a new temporal prediction
	 * for a column that has been found to lack sufficient lateral prediction.
	 * 
	 * @param h column's height position in the region
	 * @param w column's width position in the region 
	 * O(cells*ds*s_d)
	 */
	void getLearningCell(int h, int w) {
		Object[] bestCellResults = getBestPredictedCell(h, w);
		Integer bestColumnIndex = (Integer)bestCellResults[0];
		DendriteSegment bestSegment = (DendriteSegment)bestCellResults[1];
		if (bestColumnIndex == -1 || bestSegment == null) {
			bestColumnIndex = regionFactory.getRandom().nextInt(cellsPerColumn);
			bestSegment = getBestPreviousActiveSegment(cells[h][w][bestColumnIndex].getDendriteSegments());
			// If we implement the adding of new dendrite segments to cells, then 
			// random selection should be replaced by getCellMinSegments()
		}
		cells[h][w][bestColumnIndex].setLearningCurrently(true);
		learningCellIndices.put(columns[h][w], bestColumnIndex);		
		if (bestSegment != null) {
			storeSegmentUpdate(SegmentUpdateType.NEW_FIRST_ORDER, bestSegment, 
							   DendriteSegmentImpl.FIRST_ORDER_PREDICTION_TIME,
							   0, h, w, bestColumnIndex);
		} else {
			loggingStats.failedSequenceSegmentUpdates++;
		}
	}
	/**
	 * Gets the best predicted cell and its maximally predicted
	 * {@link DendriteSegment} in the column with the specified coordinates, (h,w). 
	 * The activity of {@link DendriteSegment}s is based on {@link CellState#ActivePrevious}.
	 * Returns 1) The cell index of the best-predicted cell of the specified
	 * column. <br/>
	 * 2) The best predicting {@link DendriteSegment} on the cell
	 * However, if no {@link DendriteSegment} on any of the column's cells has at least
	 * {@link #segmentLearningThreshold} previously active synapses then {-1, null} is
	 * returned. 
	 * @see #getBestMatchingSegment(Collection) 
	 * O (cells*ds*s_d)
	 */
	Object[] getBestPredictedCell(int h, int w) {
		int bestColumnIndex = -1;
		DendriteSegment bestSegment = null;
		double maxNumActiveSynapses = 0.0;
		for (int i = 0; i < cellsPerColumn; i++) {
			DendriteSegment ds = getBestPreviousActiveSegment(cells[h][w][i].getDendriteSegments());
			if (ds != null) {
				int numActiveSynapses = getActiveSynapseCount(ds.getPotentialSynapses(),
															  CellState.ActivePrevious);
				if (numActiveSynapses > maxNumActiveSynapses) {
					maxNumActiveSynapses = numActiveSynapses;
					bestColumnIndex = i;
					bestSegment = ds;
				}
			}
		}
		return new Object[] {bestColumnIndex, bestSegment};
	}

	/**
	 * Returns the {@link DendriteSegment} with the most pre-synaptic activity
	 * from {@link CellState#ActivePrevious}. All synapses, including unconnected (potential),
	 * count towards the activity. The number of active synapses is allowed to
	 * be below {@link #distalDendriteActivationThreshold} but must be above
	 * {@link #segmentLearningThreshold}. O (ds*s_d)
	 */
	DendriteSegment getBestPreviousActiveSegment(Collection<DendriteSegment> segments) {
		DendriteSegment winnner = null;
		int maxActiveSynapses = 0;
		for (DendriteSegment ds: segments) {
			int activeSynapses = getActiveSynapseCount(ds.getPotentialSynapses(), CellState.ActivePrevious);
			if (activeSynapses > segmentLearningThreshold &&
					activeSynapses > maxActiveSynapses) { 
				maxActiveSynapses = activeSynapses;
				winnner = ds;
			}
		}
		return winnner;
	}	

	/**
	 * ------Temporal Pooler Phase 2------ For each Cell, if it has an active
	 * distal dendrite segment: 1.) Mark Cell predicted 2.) Queue an update for the segment
	 * without new synapses (simple Hebbian reinforcement) to be verified in the future 3.) Queue
	 * an update for a segment that could have made the Cell predicted
	 * earlier in time. (try to build up temporal invariance, i.e. try to
	 * guess/anticipate the cells corresponding to a temporal pattern in
	 * advance) O(0.02*k*cells*ds*s_d)
	 */
	public void updatePredictiveCells() { 
		boolean isCellPredicted = false;
		boolean isCell1OrderPredicted = false;
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for (int k = 0; k < cellsPerColumn; k++) {
					isCellPredicted = false;
					isCell1OrderPredicted = false;
					for (DendriteSegment segment: cells[i][j][k].getDendriteSegments()) {
						if (isSegmentActive(segment.getConnectedSynapses(),CellState.ActiveCurrent)) {
							cells[i][j][k].setPredictedCurrently(true);
							allPredictedColumns.add(columns[i][j]);//For testing.
							if(!isCellPredicted){
								isCellPredicted=true;
								loggingStats.laterallyPredictedCells++;
							}
							if(segment.isPredictingForNextStep()){
								oneOrderPredictedColumns.add(columns[i][j]);
								if(!isCell1OrderPredicted){
									isCell1OrderPredicted=true;
									loggingStats.oneOrderPredictedCells++;
								}
							}
							int predictionOrder = segment.getPredictionTime();
							int verificationTime = predictionOrder;
							storeSegmentUpdate(SegmentUpdateType.ACTIVE_PREDICTION, segment, 
									           predictionOrder, verificationTime,
									           i, j, k);
							if(predictionOrder+1 <= predictionOrderLimit){
								DendriteSegment bestPrevious = getBestPreviousActiveSegment(cells[i][j][k].getDendriteSegments());
								if (bestPrevious != null) {
									storeSegmentUpdate(SegmentUpdateType.EXTENDING_PREDICTION, bestPrevious, 
													  predictionOrder+1, verificationTime, 
													  i, j, k);
								}
							}
						}
					}
				}
			}
		}
	}

	/**
	 * Stores a segment update for specified {@link DendriteSegment}, belonging
	 * to cell, (h,w,c), for synapses that were active at specified
	 * {@link TimeStep}. Additionally the 'newSynapses' flag specifies if the
	 * update includes new synapses.
	 * 
	 * @return the newly created {@link SegmentUpdate}
	 */
	SegmentUpdate storeSegmentUpdate(SegmentUpdateType type, DendriteSegment ds, 
									 int predictionOrder, int verificationTime,
									 int heightPos, int widthPos, int colPos) {
		SegmentUpdateImpl update = new SegmentUpdateImpl();
		update.setUpdateType(type);
		update.setDendriteSegment(ds);
		update.setPredictionTime(predictionOrder);
		update.setCellLocation(heightPos, widthPos, colPos);
		Collection<Synapse> activeSynapses = null;
		if(type == SegmentUpdateType.ACTIVE_PREDICTION){ 
			activeSynapses = getActiveSynapses(ds.getPotentialSynapses(),CellState.ActiveCurrent);
		}else{
			activeSynapses = getActiveSynapses(ds.getPotentialSynapses(),CellState.ActivePrevious);
		}
		update.setActiveSynapses(activeSynapses);
		Collection<SegmentUpdate> queuePosition = storedSegmentUpdates.get(verificationTime);
		queuePosition.add(update); 
		return update;
	}
	
	/**
	 * Returns those synapses whose inputs are active in specified activityState
	 * matrix.
	 */
	protected Collection<Synapse> getActiveSynapses(Collection<Synapse> synapses, CellState state) {
		Collection<Synapse> activeSynapses = new HashSet<Synapse>();
		switch(state){
			case ActiveCurrent:
				for (Synapse s: synapses) {
					Cell c = cells[s.getSourceHeightPos()][s.getSourceWidthPos()][s.getSourceColumn()];
					if (c.isActiveCurrently()) {
						activeSynapses.add(s);
					}
				}
				break;
			case ActivePrevious:
				for (Synapse s: synapses) {
					Cell c = cells[s.getSourceHeightPos()][s.getSourceWidthPos()][s.getSourceColumn()];
					if (c.isActivePreviously()) {
						activeSynapses.add(s);
					}
				}
				break;
			case LearningPrevious:
				for (Synapse s: synapses) {
					Cell c = cells[s.getSourceHeightPos()][s.getSourceWidthPos()][s.getSourceColumn()];
					if (c.isLearningPreviously()) {
						activeSynapses.add(s);
					}
				}
				break;
			default:
				break;
		}		
		return activeSynapses;
	}
	/**
	 * Returns the number of active synapses in specified Synapse Collection due
	 * to the specified activityState matrix.
	 */
	protected int getActiveSynapseCount(Collection<Synapse> synapses, CellState state) {
		return getActiveSynapses(synapses, state).size();
	}
	/**
	 * Returns whether there is sufficiently many active synapses in specified
	 * collection due to specified activityState for a DendriteSegment to be
	 * active.
	 */
	protected boolean isSegmentActive(Collection<Synapse> synapses,	CellState state) {
		return getActiveSynapses(synapses, state).size() > distalDendriteActivationThreshold;
	}

	/**
	 * Adds the current received structural prediction into the current predicted
	 * state. (even if it doesn't help)
	 */
	@Override
	public void processStructuralPrediction() {
		for(int i=0; i<regionHeight; i++) {
			for(int j=0; j<regionWidth; j++) {
				for(int k=0; k<cellsPerColumn; k++) {
					if(receivedStructuralPrediction.get(i*heightIndexOffset+j*cellsPerColumn+k)) {
						cells[i][j][k].setPredictedCurrently(true);
						cells[i][j][k].setStructurallyPredicted(true);
					}					
				}
			}
		}
	}
	/**
	 * Computes the region's output state, {@link #regionOutput}, 
	 * based on the logical 'or' of the cell active state and predicted state. O(k*cells)
	 */
	public void computeOutput() {
		regionOutput.clear();
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for (int k = 0; k < cellsPerColumn; k++) {
					if(cells[i][j][k].isActiveCurrently() || cells[i][j][k].isPredictedCurrently()){
						regionOutput.put(i*heightIndexOffset + j*cellsPerColumn + k, true);
					}			
				}
			}
		}
	}
	
	// O(k*s_p + n)
	/**
	 * Updates the region's top down prediction. The prediction is 
	 * in the same coordinate system as this region's {@link CorticalRegionBottomUpSource}.
	 */
	@Override
	public BitVector getGeneratedStructuralPrediction() { 
		BitVector prediction = new BitVector(bottomUpInputDimension);
		double inputPredictions[] = new double[bottomUpInputDimension];
		for (Column c: oneOrderPredictedColumns) {
			for (Synapse s: c.getConnectedSynapses()) {
				int inputIndex = s.getSourceHeightPos()*bottomUpInputSizeSqrt + s.getSourceWidthPos();
				inputPredictions[inputIndex]++;
			}
		}
		for (int i=0; i<bottomUpInputDimension; i++) {
			if(inputPredictions[i]/inputCoverage[i] > structuralPredictionThreshold){
				prediction.put(i, true);
			}
		}
		generatedStructuralPrediction = prediction;
		return prediction;
	}
//	for (Column c: oneOrderPredictedColumns) {
//	for (Synapse s: c.getConnectedSynapses()) {
//		int inputIndex = s.getSourceHeightPos()*bottomUpInputSizeSqrt + s.getSourceWidthPos();
//		generatedStructuralPrediction.set(inputIndex);
//	}
//}
	
	/**
	 * ------Temporal Pooler Phase 3------<br/>
	 * For each segment update queued for this cycle: 
	 * 	1.) If it was chosen as a learning Cell then
	 * positively reinforce the segment update. This could process new 1st order
	 * updates stored in phase 1 and/or updates queued in phase two, which was predicting future activity.
	 * We know that all currently learning cells are currently active. 
	 * 
	 *  2.) Otherwise, if the cell corresponding to a segment update is not learning,
	 *   then negatively reinforce updates.
	 */
	@Override
	public void performTemporalLearning() { 
		Collection<SegmentUpdate> updates = storedSegmentUpdates.remove(0);
		for(SegmentUpdate u: updates){
			SegmentUpdateImpl update = (SegmentUpdateImpl) u;
			int i = update.getCellHeight();
			int j = update.getCellWidth();
			int k = update.getCellColumn();
			if(cells[i][j][k].isLearningCurrently()){
				performPositiveSegmentUpdate(update, columns[i][j]);
				logPerformedUpdate(update, true);
			}else if(!cells[i][j][k].isActiveCurrently()){  
				performNegativeSegmentUpdate(update, columns[i][j]);
				logPerformedUpdate(update, false);
			}
		}
		updates.clear();
		storedSegmentUpdates.add(updates); //adds new position to queue at end maintaining its size. 
	}

	/**
	 * Positively adapts the segment updates for cell in specified column. For each
	 * segment update, positively reinforce only those synapses marked active in
	 * the SegmentUpdate; all other synapses are negatively reinforced.
	 */
	void performPositiveSegmentUpdate(SegmentUpdate update, Column column) {
		Collection<Synapse> activeSynapses = update.getActiveSynapses();
		DendriteSegment ds = update.getDendriteSegment();
		for (Synapse s: ds.getPotentialSynapses()) {
			if (activeSynapses.contains(s)) {
				updatePermanence(s, ds, distalPermanenceIncrement);
			} else {
				updatePermanence(s, ds, distalPositivePermanenceDecrement);
			}
		}
		auxPerformSegmentUpdate(update, column);
	}

	/**
	 * Negatively adapts the segment update for cell in specified column. For each
	 * segment update, negatively reinforce only those synapses marked active in
	 * the SegmentUpdate.
	 */
	void performNegativeSegmentUpdate(SegmentUpdate update, Column column) {
		DendriteSegment ds = update.getDendriteSegment();
		Collection<Synapse> activeSynapses = update.getActiveSynapses();
		for (Synapse s: activeSynapses) {
			updatePermanence(s, ds, distalNegativePermanenceDecrement);
		}
		auxPerformSegmentUpdate(update, column);
	}

	/*
	 * Updates the segments prediction time. 
	 * If the update type requires new synapses to be added, then make them and add them.	 
	 * @param update The SegmentUpdate to be processed.
	 * @param column The Column to which the DendriteSegment belongs
	 * @param isPositive Strictly for logging.
	 */
	private void auxPerformSegmentUpdate(SegmentUpdate update, Column column) {
		DendriteSegment segment = update.getDendriteSegment();
		segment.setPredictionTime(update.getPredictionOrder());
		SegmentUpdateType type = update.getUpdateType();		
		boolean shouldAddSynapses = type==SegmentUpdateType.NEW_FIRST_ORDER ||
									type==SegmentUpdateType.EXTENDING_PREDICTION;		
		if (shouldAddSynapses) {
			int perUpdateSynapseLimit = maxNewDistalSynapsesPerUpdate-update.getActiveSynapses().size();
			int perSegmentSynapseLimit = maxDistalSynapsesPerSegment-segment.getPotentialSynapseCount();
			int numNewSynapses = Math.min(perUpdateSynapseLimit,perSegmentSynapseLimit);			
			if(numNewSynapses > 0){
				for (Synapse s: getNewDistalSynapses(numNewSynapses, column)) {
					segment.addPotentialSynapse(s);
					if (s.getPermanence() >= synapseConnectionThreshold) {
						segment.addConnectedSynapse(s);
					}
				}
			}else if(perSegmentSynapseLimit <= 0){//Extension: add more DendriteSegments in this case.
				logger.log(Level.FINEST,
						"Cannot add new synapses because segment already has 'maxDistalSynapsesPerSegment' potential synapses.");
			}else{
				logger.log(Level.FINEST,
						"Cannot add new synapses because segment already has 'maxNewDistalSynapsesPerUpdate' synapses active.");
			}
		}
	}
	private void logPerformedUpdate(SegmentUpdate update, boolean isPositive){
		switch (update.getUpdateType()) { 
			case NEW_FIRST_ORDER:
				if (isPositive) {
					loggingStats.oneOrderPositiveUpdates++;
				} else {
					loggingStats.oneOrderNegativeUpdates++;
				}
				break;
			case ACTIVE_PREDICTION:
				if (isPositive) {
					loggingStats.activePredictionPositiveUpdates++;
				} else {
					loggingStats.activePredictionNegativeUpdates++;
				}
				break;
			case EXTENDING_PREDICTION:
				if (isPositive) {
					loggingStats.higherOrderPositiveUpdates++;
				} else {
					loggingStats.higherOrderNegativeUpdates++;
				}
				break;
			default:
				break;
		}
		loggingStats.predictionOrderSum += update.getPredictionOrder();
	}

	/**
	 * Return a collection of new synapses having their source cell randomly
	 * chosen among those learning cells within a circular neighborhood about
	 * the specified column of radius, {@link #distalLearningRadius}.
	 * 
	 * @param maxSynapses
	 *            the maximum number of new synapses to be created
	 * @param center
	 *            the {@link Column} at the center of the circle in column
	 *            coordinates from which the synapses' input sources will be
	 *            randomly selected.
	 * @return a collection of new distal synapses whose input sources are the
	 *         neighboring learning cells of the center column.
	 */
	Collection<Synapse> getNewDistalSynapses(int maxSynapses, Column center) {
		Collection<Synapse> newSynapses = new ArrayList<Synapse>();
		List<Column> neighbors = distalLearningNeighbors.get(center);
		while (!neighbors.isEmpty() && maxSynapses > 0) {
			Column nbrColumn = neighbors.remove(0);
			Integer k = learningCellIndices.get(nbrColumn);
			if (k != null) {
				int i = nbrColumn.getRegionHeightPosition();
				int j = nbrColumn.getRegionWidthPosition();
				Synapse s = regionFactory.getSynapse(i,j,k,initialDistalSynapsePermanence);
				if (s != null) {
					newSynapses.add(s);
				}
				maxSynapses--;
			}
		}
		loggingStats.distalSynapsesAdded += newSynapses.size();
		return newSynapses;
	}

	/**
	 * Returns cell with the fewest dendrite segments in specified column (h,w).
	 * 
	 * @return 1. cell index, 2. most active segment
	 * @see #getBestMatchingSegment(Collection)
	 */
	Object[] getCellMinSegments(int h, int w) {
		int minColumnIndex = -1;
		DendriteSegment segment = null;
		int minNumSegments = Integer.MAX_VALUE;
		for (int i = 0; i < cellsPerColumn; i++) {
			if (cells[h][w][i].getDendriteSegmentCount() < minNumSegments) {
				minNumSegments = cells[h][w][i].getDendriteSegmentCount();
				minColumnIndex = i;
			}
		}
		segment = getBestPreviousActiveSegment(cells[h][w][minColumnIndex].getDendriteSegments());
		return new Object[] {minColumnIndex, segment};
	}

	@Override
	public void setReceivedStructuralPrediction(Object b) {
		receivedStructuralPrediction = (BitVector) b;
	}	
	@Override
	public BitVector getOutputSignal() {
		return regionOutput.copy();
	}
	public int getRegionHeight() {
		return regionHeight;
	}
	public int getRegionWidth() {
		return regionWidth;
	}
	@Override
	public int getCellsPerColumn() {
		return cellsPerColumn;
	}
	@Override
	public int getOutputDimensionality() {
		return cellCount;
	}
	
	public int getBottomUpInputSizeSqrt() {
		return bottomUpInputSizeSqrt;
	}
	
	public void decay() {
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for (int k = 0; k < cellsPerColumn; k++) {
					for (DendriteSegment ds: cells[i][j][k].getDendriteSegments()) {
						for (Synapse s: ds.getPotentialSynapses()) {
							double p = decayStrategy.decay(s.getPermanence(),1L);
							s.setPermanence(p); //todo change decay strategy to excite strategy
							updatePermanence(s, ds, 0.0);
						}
					}
				}
			}
		}
	}
	@Override
	public void decayModule(long t) {
		// For now decay() is called by CorticalRegionTask instead.
	}

	/**
	 * Returns content for the GUI.
	 * @see CorticalRegionVisualizer
	 */
	@Override
	public Object getModuleContent(Object... params) {
		if (params != null && params.length > 0 && params[0] != null) {
			CorticalRegionAspect content = (CorticalRegionAspect) params[0];
			switch (content) {
			case ActiveColumns:
				return getGuiColumnState(activeColumns);
			case OverlappingColumns:
				return getGuiColumnState(overlappingColumns);
			case CurrentPredictedColumns:
				return getGuiColumnState(oneOrderPredictedColumns);
			case OnePreviousPredictedColumns:
				return getGuiColumnState(onePreviousPredictedColumns);
			case ActiveCurrentlyCells:
				return cells;
			case ActivePreviouslyCells:
				return cells;
			case PredictedCurrentlyCells:
				return cells;
			case PredictedPreviouslyCells:
				return cells;
			case LearningCurrentlyCells:
				return cells;
			case LearningPreviouslyCells:
				return cells;
			case StructurallyPredictedCells:
				return cells;
			case AverageColumnActivity:
				return getGuiColumnAttribute(CorticalRegionAspect.AverageColumnActivity);
			case AverageColumnOverlap:
				return getGuiColumnAttribute(CorticalRegionAspect.AverageColumnOverlap);
			case ColumnBoost:
				return getGuiColumnAttribute(CorticalRegionAspect.ColumnBoost);
			}
		}
		return null;
	}
	private boolean[][] getGuiColumnState(Collection<Column> columns) {
		boolean[][] state = new boolean[regionHeight][regionWidth];
		for (Column c : columns) {
			state[c.getRegionHeightPosition()][c.getRegionWidthPosition()] = true;
		}
		return state;
	}
	private static final double DEFAULT_AVERAGE_COLUMN_ACTIVITY_SCALING = 10;
	private double[][] getGuiColumnAttribute(CorticalRegionAspect state) {
		double[][] activity = new double[regionHeight][regionWidth];
		switch (state) {
			case AverageColumnActivity:
				for (int i = 0; i < regionHeight; i++) {
					for (int j = 0; j < regionWidth; j++) {
						activity[i][j] = 1/(1 + Math.exp(-DEFAULT_AVERAGE_COLUMN_ACTIVITY_SCALING
								* columns[i][j].getAverageActivity()));
					}
				}
				break;
			case AverageColumnOverlap:
				for (int i = 0; i < regionHeight; i++) {
					for (int j = 0; j < regionWidth; j++) {
						activity[i][j] = columns[i][j].getAverageOverlap();
					}
				}
				break;
			case ColumnBoost:
				double guiMaxBoost = 1.0;// Because of the run-time nature of this call.
				for (int i = 0; i < regionHeight; i++) {
					for (int j = 0; j < regionWidth; j++) {
						if (columns[i][j].getBoost() > guiMaxBoost) {
							guiMaxBoost = columns[i][j].getBoost();
						}
					}
				}
				for (int i = 0; i < regionHeight; i++) {
					for (int j = 0; j < regionWidth; j++) {
						activity[i][j] = columns[i][j].getBoost()	/
											guiMaxBoost;
					}
				}
				break;
			default:
				break;
		}
		return activity;
	}

	public void logRegionState() {
		double falsePositives1Step = 0;
		double falseNegatives1Step = 0;
		double truePositives1Step = 0;
		for (Column predicted: onePreviousPredictedColumns) {
			if (activeColumns.contains(predicted)) {
				truePositives1Step++;
			} else {
				falsePositives1Step++; // Type I
			}
		}
		for (Column active : activeColumns) {
			if (!onePreviousPredictedColumns.contains(active)) {
				falseNegatives1Step++; // Type II
			}
		}
		// Precision = activePredicted / (activePredicted + inactivePredicted (type I))
		// Recall = activePredicted / (activePredicted + activeUnpredicted (type II))
		double precisionOrder1 = 1.0;
		if(truePositives1Step + falsePositives1Step != 0){
			precisionOrder1 = truePositives1Step / (truePositives1Step + falsePositives1Step); 
		}		
		double recallOrder1 = 1.0;
		if(truePositives1Step + falseNegatives1Step != 0){
			recallOrder1 = truePositives1Step / (truePositives1Step + falseNegatives1Step);
		}
		double f1Order1 = 0.0;
		if(precisionOrder1 + recallOrder1 != 0){		
			f1Order1 = 2*precisionOrder1*recallOrder1/ (precisionOrder1 + recallOrder1);
		}
		
		Object[] params = new Object[2];
		params[0] = TaskManager.getCurrentTick();
		params[1] = (double) activeColumns.size() / columnCount;
		logger.log(Level.FINE, ClaMeasure._ColumnActivity + ": {1}", params);
		params[1] = f1Order1;
		logger.log(Level.FINE, ClaMeasure._Column1OrderPrediction_FScore + ": {1}",
				params);
		params[1] = precisionOrder1;
		logger.log(Level.FINER, ClaMeasure._Column1OrderPrediction_Precision
				+ ": {1}", params);
		params[1] = recallOrder1;
		logger.log(Level.FINER, ClaMeasure._Column1OrderPrediction_Recall
				+ ": {1}", params);
		if (logger.isLoggable(Level.FINEST)) {
			double aveColBoostedOverlap = 0;
			double aveColAveOverlap = 0;
			double aveColAveActivity = 0;
			double aveColBoost = 0;
			double aveColPercentConnected = 0;
			for (int i = 0; i < regionHeight; i++) {
				for (int j = 0; j < regionWidth; j++) {
					Column c = columns[i][j];
					aveColBoostedOverlap += c.getBoostedOverlap();
					aveColAveOverlap += c.getAverageOverlap();
					aveColAveActivity += c.getAverageActivity();
					aveColBoost += c.getBoost();
					aveColPercentConnected += (double)c.getConnectedSynapses().size() / 
												c.getPotentialSynapses().size();
				}
			}
			params[1] = loggingStats.avgOverThresholdOverlapPercentage;
			logger.log(Level.FINEST, ClaMeasure.AvgOverThresholdOverlapPercentage
					+ ": {1}", params);
			params[1] = inhibitionRadius;
			logger.log(Level.FINEST, ClaMeasure.ColumnsInhibitionRadius
					+ ": {1}", params);
			params[1] = aveColAveOverlap / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ColumnsAveOverlapHistory
					+ ": {1}", params);
			params[1] = aveColAveActivity / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ColumnsAveActivityHistory
					+ ": {1}", params);
			params[1] = aveColBoost / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ColumnsAveBoost + ": {1}",
					params);
			params[1] = loggingStats.maxBoostInCycle;
			logger.log(Level.FINEST, ClaMeasure.ColumnsMaxBoost + ": {1}",
					params);
			params[1] = aveColBoostedOverlap / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ColumnsAveBoostedOverlap
					+ ": {1}", params);
			params[1] = loggingStats.columnsWithBoostedSynapses / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ColumnsWithBoostedSynapses
					+ ": {1}", params);
			params[1] = aveColPercentConnected / columnCount;
			logger.log(Level.FINEST, ClaMeasure.ProximalSynapseConnectivity
					+ ": {1}", params);
			int activeColumnCellCount = cellsPerColumn*activeColumns.size();
			params[1] = loggingStats.correctlyPredictingCells / activeColumnCellCount;
			logger.log(Level.FINEST, ClaMeasure.CellsTruePositive + ": {1}",
					params);
			double haveActiveSegment = 0.0;
			double alsoSequenceSegment = 0.0;
			double predictedByLearningCells = 0.0;
			if (loggingStats.correctlyPredictingCells != 0) {
				haveActiveSegment = loggingStats.activePredictingSegment
						/ loggingStats.correctlyPredictingCells;
				alsoSequenceSegment = loggingStats.activePredictingSequenceSegments
						/ loggingStats.correctlyPredictingCells;
				predictedByLearningCells = loggingStats.learningActivePredictingSequenceSegments
						/ loggingStats.correctlyPredictingCells;
			}
			params[1] = haveActiveSegment;
			logger.log(Level.FINEST, ClaMeasure.CellsTruePositiveActiveSegment
					+ ": {1}", params);
			params[1] = alsoSequenceSegment;
			logger.log(Level.FINEST,
					ClaMeasure.CellsTruePositiveSequenceSegment + ": {1}",
					params);
			params[1] = predictedByLearningCells;
			logger.log(Level.FINEST,
					ClaMeasure.CellsTruePositiveLearningPredicted + ": {1}",
					params);
		}
		//Temporal Pooler /cells logging
		double numActiveCells = 0;
		double numStructurallyPredictedCells = 0;
		double totalConnectedDistalSynapses = 0;
		double totalPotentialDistalSynapses = 0;
		double distalSegmentsCount = 0;
		double potentialUpdates = 0;
		double existingPredictionUpdates = 0;
		double extendingPredictionUpdates = 0;
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for (int k = 0; k < cellsPerColumn; k++) {
					Collection<DendriteSegment> distalDendrites = cells[i][j][k].getDendriteSegments();
					distalSegmentsCount += distalDendrites.size();
					for (DendriteSegment ds : distalDendrites) {
						totalConnectedDistalSynapses += ds
								.getConnectedSynapses().size();
						totalPotentialDistalSynapses += ds
								.getPotentialSynapses().size();
					}
					if (cells[i][j][k].isActiveCurrently()) {
						numActiveCells++;
					}
					if (cells[i][j][k].isStructurallyPredicted()) {
						numStructurallyPredictedCells++;
					}
					for(Collection<SegmentUpdate> updates: storedSegmentUpdates){
						potentialUpdates += updates.size();
						for(SegmentUpdate u: updates){
							switch(u.getUpdateType()){
								case ACTIVE_PREDICTION:
									existingPredictionUpdates++;
									break; 
								case EXTENDING_PREDICTION:
									extendingPredictionUpdates++;
									break;
								default:
									break;
							}
						}
					}
				}
			}
		}
		params[1] = numActiveCells / cellCount;
		logger.log(Level.FINE, ClaMeasure.CellsActivePercentage + ": {1}", params);		
		params[1] = (loggingStats.laterallyPredictedCells + numStructurallyPredictedCells) / cellCount;
		logger.log(Level.FINE, ClaMeasure.CellsAllPredictedPercentage + ": {1}", params);		
		params[1] = loggingStats.laterallyPredictedCells / cellCount;
		logger.log(Level.FINE, ClaMeasure.CellsAllLateralPredictedPercentage + ": {1}", params);		
		params[1] = loggingStats.oneOrderPredictedCells / cellCount;
		logger.log(Level.FINE, ClaMeasure.Cells1OrderLateralPredictedPercentage + ": {1}", params);		
		params[1] = numStructurallyPredictedCells / cellCount;
		logger.log(Level.FINE, ClaMeasure.CellsStructurallyPredictedPercentage + ": {1}", params);
		
		params[1] = totalPotentialDistalSynapses;
		logger.log(Level.FINER, ClaMeasure.DistalSynapsesPotential + ": {1}",
				params);
		params[1] = totalConnectedDistalSynapses;
		logger.log(Level.FINER, ClaMeasure.DistalSynapsesConnected + ": {1}",
				params);
		params[1] = totalConnectedDistalSynapses / totalPotentialDistalSynapses;
		logger.log(Level.FINER,
				ClaMeasure.DistalSynapseConnectionRate + ": {1}", params);		
		params[1] = loggingStats.distalSynapsesAdded;
		logger.log(Level.FINER, ClaMeasure.DistalSynapsesAdded + ": {1}",
				params);
		params[1] = loggingStats.distalSynapsesRemoved;
		logger.log(Level.FINER, ClaMeasure.DistalSynapsesRemoved + ": {1}",
				params);
		if (logger.isLoggable(Level.FINEST)) {
			params[1] = totalConnectedDistalSynapses / distalSegmentsCount;
			logger.log(Level.FINEST, ClaMeasure.DistalSynapsesConnectedPerSegment
					+ ": {1}", params);
			params[1] = totalPotentialDistalSynapses / distalSegmentsCount;
			logger.log(Level.FINEST, ClaMeasure.DistalSynapsesPotentialPerSegment
					+ ": {1}", params);			
			
			double chosenLearningRatio = 0.0;
			if (activeColumns.size() != 0) {
				chosenLearningRatio = loggingStats.chosenLearningCellCount	/
										activeColumns.size();
			}
			double failedSSUpdates = 0.0;
			if (loggingStats.chosenLearningCellCount != 0.0) {
				failedSSUpdates = loggingStats.failedSequenceSegmentUpdates /
									loggingStats.chosenLearningCellCount;
			}
			params[1] = 1 - chosenLearningRatio;
			logger.log(Level.FINEST, ClaMeasure.LearningCellsPredicted
					+ ": {1}", params);
			params[1] = chosenLearningRatio;
			logger.log(Level.FINEST, ClaMeasure.LearningCellsChosen + ": {1}",
					params);
			params[1] = failedSSUpdates;
			logger.log(Level.FINEST,
					ClaMeasure.LearningCellsFailed1StepSegmentSelection
							+ ": {1}", params);
			//SegmentUpdate Logging
			double oneOrderPerformed = loggingStats.oneOrderPositiveUpdates
					+ loggingStats.oneOrderNegativeUpdates;
			double reinforcingPerformed = loggingStats.activePredictionPositiveUpdates
					+ loggingStats.activePredictionNegativeUpdates;
			double twoOrderPerformed = loggingStats.higherOrderPositiveUpdates
					+ loggingStats.higherOrderNegativeUpdates;
			double totalUpdatesPerformed = oneOrderPerformed
					+ reinforcingPerformed + twoOrderPerformed;
			params[1] = potentialUpdates;
			logger.log(Level.FINEST, ClaMeasure.QueuedUpdates + ": {1}",
					params);			
			params[1] = existingPredictionUpdates;
			logger.log(Level.FINEST,
					ClaMeasure.QueuedUpdates_ActivePrediction + ": {1}",
					params);
			params[1] = extendingPredictionUpdates;
			logger.log(Level.FINEST, ClaMeasure.QueuedUpdates_ExtendingPrediction
					+ ": {1}", params);
			params[1] = totalUpdatesPerformed;
			logger.log(Level.FINEST, ClaMeasure.PerformedUpdates + ": {1}",
					params);
			params[1] = oneOrderPerformed;
			logger.log(Level.FINEST, ClaMeasure.PerformedUpdates_New1Order
					+ ": {1}", params);
			params[1] = reinforcingPerformed;
			logger.log(Level.FINEST, ClaMeasure.PerformedUpdates_ActivePrediction + ": {1}",
					params);
			params[1] = twoOrderPerformed;
			logger.log(Level.FINEST, ClaMeasure.PerformedUpdates_ExtendingPrediction
					+ ": {1}", params);
			params[1] = loggingStats.predictionOrderSum/totalUpdatesPerformed;
			logger.log(Level.FINEST, ClaMeasure._PerformedUpdates_AvePredictionOrder
					+ ": {1}", params);			
		}
		
	}
	/** Intended for testing only. */
	void setColumns(Column[][] cols) {
		columns = cols;
	}
	/** Intended for testing only. */
	public Collection<Column> getActiveColumns() {
		return new HashSet<Column>(activeColumns);
	}
	/** Intended for testing only. */
	void setActiveColumns(Collection<Column> cols) {
		activeColumns = cols;
	}
	/** Intended for testing only. */
	Column getColumn(int i, int j) {
		return columns[i][j];
	}
	/** Intended for testing only. */
	void setLearningCells(Map<Column, Integer> indices) {
		learningCellIndices = indices;
	}
	/** Intended for testing only. */
	void setCell(int i, int j, int k, Collection<DendriteSegment> segs) {
		cells[i][j][k].setDendriteSegments(segs);
	}
	/** Intended for testing only. */
	void setInhibitionRadius(double d) {
		inhibitionRadius = d;
	}
	/** Intended for testing only. */
	void setInput(BitVector input) {
		bottomUpInput = input;
	}
	/** Intended for testing only. */
	public Column[][] getColumns() {
		return columns;
	}
	/** Intended for testing only. */
	public int getColumnCount() {
		return columnCount;
	}
	/** Intended for testing only. */
	public double getInhibitionRadius() {
		return inhibitionRadius;
	}
	/** Intended for testing only. */
	public void setCurrentPredictedColumns(Collection<Column> cols) {
		oneOrderPredictedColumns = cols;
	}
	/** Intended for testing only. */
	public Collection<Column> getCurrentPredictedColumns() {
		return oneOrderPredictedColumns;
	}
	/** Intended for testing only. */
	public Collection<Column> getAllPredictedColumns(){
		return allPredictedColumns;
	}
	/** Intended for testing only. */
	void setLocalColumnActivity(double d) {
		localColumnActivity = d;
	}
	/** Intended for testing only. */
	public List<Collection<SegmentUpdate>> getPotentialSegmentUpdates() {
		return storedSegmentUpdates;
	}
	/** Intended for testing only. */
	public void clearRegionState() {
		activeColumns.clear();
		onePreviousPredictedColumns.clear();
		oneOrderPredictedColumns.clear();
		allPredictedColumns.clear();
		clearPotentialSegmentUpdates();
		for (int i = 0; i < regionHeight; i++) {
			for (int j = 0; j < regionWidth; j++) {
				for(int k = 0; k < cellsPerColumn; k++) {
					cells[i][j][k].clearState();
				}
			}
		}
		learningCellIndices.clear();
	}
	/** Intended for testing only. */
	public void setCells(Cell[][][] cells) {
		this.cells = cells;
	}
	/** Intended for testing only. */
	public void setBoostSlope(double s) {
		((DefaultBoostStrategy)boostStrategy).setSlope(s);
	}
	/** Intended for testing only. */
	public void setPredictionOrderLimit(int l){
		predictionOrderLimit=l;
	}
	/** Intended for testing only. */
	public double getCycleSpatialSynapticChanges(){
		return cycleSpatialSynapticChanges;
	}
}